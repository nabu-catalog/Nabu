type AccessCondition {
  collections: [Collection]
  items: [Item]
  name: String
}

type Agent {
  role_name: String
  user: Person
  user_name: String
}

"""
Represents non-fractional signed whole numeric values. Since the value may
exceed the size of a 32-bit integer, it's encoded as a string.
"""
scalar BigInt

type Boundary {
  east_limit: Float!
  north_limit: Float!
  south_limit: Float!
  west_limit: Float!
}

type Collection {
  access_class: String
  access_narrative: String
  boundaries: Boundary
  citation: String
  collector: Person
  comments: String
  complete: Boolean
  content_languages: [Language]
  countries: [Country]
  description: String
  doi: String
  doi_xml: String
  field_of_research: FieldOfResearch
  grants: [Grant]
  id: ID!
  identifier: String!
  media: String
  metadata_source: String
  operator: Person
  orthographic_notes: String
  permalink: String!
  region: String
  subject_languages: [Language]
  tape_location: Boolean
  title: String!
  university: University
}

type Country {
  boundaries: [Boundary]
  code: String!
  id: ID!
  languages: [Language]
  name: String!
}

type DataCategory {
  id: ID!
  items: [Item]
  name: String!
}

type DataType {
  id: ID!
  items: [Item]
  name: String!
}

type DiscourseType {
  id: ID!
  items: [Item]
  name: String!
}

type EmailUser {
  email: String
  firstName: String
  lastName: String
}

type Essence {
  bitrate: Int
  channels: Int
  citation: String
  collection: Collection
  collectionId: Int
  createdAt: ISO8601DateTime
  derivedFilesGenerated: Boolean
  doi: String
  doi_xml: String
  duration: Float
  filename: String
  fps: Int
  id: ID!
  item: Item
  itemId: Int
  mimetype: String
  permalink: String
  samplerate: Int
  size: BigInt
  updatedAt: ISO8601DateTime
}

"""
Attributes for creating or updating an essence
"""
input EssenceAttributes {
  bitrate: Int
  channels: Int
  duration: Float
  fps: Int
  mimetype: String!
  samplerate: Int
  size: Int!
}

"""
Autogenerated input type of EssenceCreate
"""
input EssenceCreateInput {
  attributes: EssenceAttributes!

  """
  A unique identifier for the client performing the mutation.
  """
  clientMutationId: String
  collectionIdentifier: String!
  filename: String!
  itemIdentifier: String!
}

"""
Autogenerated return type of EssenceCreate.
"""
type EssenceCreatePayload {
  """
  A unique identifier for the client performing the mutation.
  """
  clientMutationId: String
  essence: Essence!
}

"""
Autogenerated input type of EssenceUpdate
"""
input EssenceUpdateInput {
  attributes: EssenceAttributes!

  """
  A unique identifier for the client performing the mutation.
  """
  clientMutationId: String
  id: ID!
}

"""
Autogenerated return type of EssenceUpdate.
"""
type EssenceUpdatePayload {
  """
  A unique identifier for the client performing the mutation.
  """
  clientMutationId: String
  essence: Essence!
}

type FieldOfResearch {
  collections: [Collection]
  id: ID!
  identifier: String!
  name: String!
}

type FundingBody {
  funded_collections: [Collection]
  grants: [Grant]
  id: ID!
  key_prefix: String
  name: String!
}

type Grant {
  collection: Collection
  funding_body: FundingBody
  id: ID!
  identifier: String
}

"""
An ISO 8601-encoded datetime
"""
scalar ISO8601DateTime @specifiedBy(url: "https://tools.ietf.org/html/rfc3339")

type Item {
  access_class: String
  access_condition: AccessCondition
  access_condition_name: String
  access_narrative: String
  born_digital: Boolean
  boundaries: Boundary
  citation: String
  collection: Collection!
  collector: Person!
  content_languages: [Language]
  countries: [Country]
  created_at: ISO8601DateTime
  data_categories: [DataCategory]
  data_types: [DataType]
  description: String
  dialect: String
  digitised_on: String
  discourse_type: DiscourseType
  doi: String
  doi_xml: String
  essences: [Essence]
  essences_count: Int
  full_identifier: String!
  id: ID!
  identifier: String!
  ingest_notes: String
  item_agents: [Agent]
  language: String
  metadata_exportable: Boolean!
  operator: Person
  original_media: String
  originated_on: String
  originated_on_narrative: String
  permalink: String!
  private: Boolean
  public: Boolean
  received_on: String
  region: String
  subject_languages: [Language]
  title: String
  tracking: String
  university: University
  updated_at: ISO8601DateTime
}

type ItemBwfCsv {
  collectionIdentifier: String!
  createdAt: ISO8601DateTime
  csv: String!
  fullIdentifier: String!
  itemIdentifier: String!
  updatedAt: ISO8601DateTime
}

type ItemId3 {
  collectionIdentifier: String!
  createdAt: ISO8601DateTime
  fullIdentifier: String!
  itemIdentifier: String!
  txt: String!
  updatedAt: ISO8601DateTime
}

type ItemResult {
  next_page: Int
  results: [Item]!
  total: Int!
}

type Language {
  archive_link: String
  code: String!
  collection: [Collection]
  countries: [Country]
  id: ID!
  items_for_content: [Item]
  items_for_language: [Item]
  name: String!
  retired: Boolean
}

type Mutation {
  """
  Creates a new essence
  """
  essenceCreate(
    """
    Parameters for EssenceCreate
    """
    input: EssenceCreateInput!
  ): EssenceCreatePayload

  """
  Updates a essence by id
  """
  essenceUpdate(
    """
    Parameters for EssenceUpdate
    """
    input: EssenceUpdateInput!
  ): EssenceUpdatePayload
}

type Person {
  collected_items: Item
  country: String
  first_name: String
  id: ID!
  last_name: String
  name: String
}

type Query {
  """
  Find a collection by identifier. e.g. NT1
  """
  collection(identifier: ID!): Collection

  """
  Find a collection by identifier. e.g. NT1
  """
  essence(filename: String!, fullIdentifier: ID!): Essence

  """
  Find an item by full identifier. e.g. NT1-009
  """
  item(fullIdentifier: ID!): Item

  """
  Get the BWF CSV for an item
  """
  itemBwfCsv(filename: String!, fullIdentifier: ID!): ItemBwfCsv

  """
  Get the ID3 XML for an item
  """
  itemId3(fullIdentifier: ID!): ItemId3
  items(access_class: String, access_condition_name: String, access_narrative: String, born_digital: Boolean, collection_identifier: String, collector_name: String, description: String, dialect: String, digitised_on: String, discourse_type_name: String, doi: String, essences_count: Int, full_identifier: String, id: ID, identifier: String, ingest_notes: String, language: String, limit: Int = 10, operator_name: String, original_media: String, originated_on: String, originated_on_narrative: String, page: Int = 1, private: Boolean, received_on: String, region: String, title: String, tracking: String, university_name: String): ItemResult

  """
  Find a user by their unikey
  """
  userByUnikey(unikey: String!): EmailUser
}

type University {
  collections: [Collection]
  id: ID!
  items: [Item]
  name: String!
  party_identifier: String
}
